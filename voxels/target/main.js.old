const assert = (x, message) => {
    if (x)
        return;
    throw new Error(message ? message() : 'Assertion failed!');
};
const drop = (xs, x) => {
    for (let i = 0; i < xs.length; i++) {
        if (xs[i] !== x)
            continue;
        xs[i] = xs[xs.length - 1];
        xs.pop();
        return;
    }
};
const nonnull = (x, message) => {
    if (x !== null)
        return x;
    throw new Error(message ? message() : 'Unexpected null!');
};
//////////////////////////////////////////////////////////////////////////////
class Tensor3 {
    constructor(x, y, z) {
        this.data = new Uint32Array(x * y * z);
        this.shape = [x, y, z];
        this.stride = [1, x, x * y];
    }
    get(x, y, z) {
        return this.data[this.index(x, y, z)];
    }
    set(x, y, z, value) {
        this.data[this.index(x, y, z)] = value;
    }
    index(x, y, z) {
        return x * this.stride[0] + y * this.stride[1] + z * this.stride[2];
    }
}
;
//////////////////////////////////////////////////////////////////////////////
// The game engine:
const Constants = {
    CHUNK_SIZE: 16,
    CHUNK_KEY_BITS: 8,
    TICK_RESOLUTION: 4,
    TICKS_PER_FRAME: 4,
    TICKS_PER_SECOND: 30,
    CAMERA_SENSITIVITY: 10,
};
class Container {
    constructor(id) {
        this.element = nonnull(document.getElementById(id), () => id);
        this.canvas = nonnull(this.element.querySelector('canvas'));
        this.inputs = { up: false, left: false, down: false, right: false, pointer: false };
        this.deltas = { x: 0, y: 0 };
        this.bindings = new Map();
        this.bindings.set('W'.charCodeAt(0), 'up');
        this.bindings.set('A'.charCodeAt(0), 'left');
        this.bindings.set('S'.charCodeAt(0), 'down');
        this.bindings.set('D'.charCodeAt(0), 'right');
        const element = this.element;
        element.addEventListener('keydown', e => this.onKeyInput(e, true));
        element.addEventListener('keyup', e => this.onKeyInput(e, false));
        element.addEventListener('click', () => element.requestPointerLock());
        document.addEventListener('pointerlockchange', e => this.onPointerInput(e));
        document.addEventListener('mousemove', e => this.onMouseMove(e));
    }
    onKeyInput(e, down) {
        const input = this.bindings.get(e.keyCode);
        if (input)
            this.onInput(e, input, down);
    }
    onMouseMove(e) {
        if (!this.inputs.pointer)
            return;
        this.deltas.x += e.movementX;
        this.deltas.y += e.movementY;
    }
    onPointerInput(e) {
        const locked = document.pointerLockElement === this.element;
        this.onInput(e, 'pointer', locked);
    }
    onInput(e, input, state) {
        this.inputs[input] = state;
        e.stopPropagation();
        e.preventDefault();
    }
}
;
;
const kBlack = [0, 0, 0];
const kWhite = [1, 1, 1];
class Registry {
    constructor() {
        this._opaque = [false];
        this._solid = [false];
        const none = 0;
        this._faces = [none, none, none, none, none, none];
        this._materials = [];
        this._ids = new Map();
    }
    addBlock(xs, solid) {
        const materials = (() => {
            switch (xs.length) {
                // All faces for this block use same material.
                case 1: return [xs[0], xs[0], xs[0], xs[0], xs[0], xs[0]];
                // xs specifies [top/bottom, sides]
                case 2: return [xs[1], xs[1], xs[0], xs[0], xs[1], xs[1]];
                // xs specifies [top, bottom, sides]
                case 3: return [xs[2], xs[2], xs[0], xs[1], xs[2], xs[2]];
                // xs specifies [+x, -x, +y, -y, +z, -z]
                case 6: return xs;
                // Uninterpretable case.
                default: throw new Error(`Unexpected materials: ${JSON.stringify(xs)}`);
            }
        })();
        const result = this._opaque.length;
        this._opaque.push(solid);
        this._solid.push(solid);
        materials.forEach(x => {
            const material = this._ids.get(x);
            if (material === undefined)
                throw new Error(`Unknown material: ${x}`);
            this._faces.push(material + 1);
        });
        return result;
    }
    addMaterialOfColor(name, color, alpha = 1.0) {
        this.addMaterialHelper(name, alpha, color, null, false);
    }
    addMaterialOfTexture(name, texture, textureAlpha = false) {
        this.addMaterialHelper(name, 1, kWhite, texture, textureAlpha);
    }
    // faces has 6 elements for each block type: [+x, -x, +y, -y, +z, -z]
    getBlockFaceMaterial(id, face) {
        return this._faces[id * 6 + face];
    }
    getMaterial(id) {
        assert(0 < id && id <= this._materials.length);
        return this._materials[id - 1];
    }
    addMaterialHelper(name, alpha, color, texture, textureAlpha) {
        assert(name.length > 0, () => 'Empty material name!');
        assert(!this._ids.has(name), () => `Duplicate material: ${name}`);
        this._ids.set(name, this._materials.length);
        this._materials.push({ alpha, color, texture, textureAlpha });
    }
}
;
//////////////////////////////////////////////////////////////////////////////
class Camera {
    constructor(scene) {
        const origin = new BABYLON.Vector3(0, 0, 0);
        this.holder = new BABYLON.TransformNode('holder', scene);
        this.camera = new BABYLON.FreeCamera('camera', origin, scene);
        this.camera.parent = this.holder;
        this.camera.minZ = 0.01;
        this.pitch = 0;
        this.heading = 0;
        this.direction = new BABYLON.Vector3(0, 0, 1);
    }
    applyInputs(dx, dy) {
        let pitch = this.holder.rotation.x;
        let heading = this.holder.rotation.y;
        // Overwatch uses the same constant values to do this conversion.
        const conversion = 0.0066 * Math.PI / 180;
        dx = dx * Constants.CAMERA_SENSITIVITY * conversion;
        dy = dy * Constants.CAMERA_SENSITIVITY * conversion;
        this.heading += dx;
        const T = 2 * Math.PI;
        while (this.heading < 0)
            this.heading += T;
        while (this.heading > T)
            this.heading -= T;
        const U = Math.PI / 2 - 0.01;
        this.pitch = Math.max(-U, Math.min(U, this.pitch + dy));
        this.holder.rotation.x = this.pitch;
        this.holder.rotation.y = this.heading;
        // Compute the direction: rotate around the X-axis, then the Y-axis.
        const cp = Math.cos(this.pitch);
        const sp = Math.sin(this.pitch);
        const ch = Math.cos(this.heading);
        const sh = Math.sin(this.heading);
        this.direction.copyFromFloats(sh * cp, -sp, ch * cp);
    }
    setPosition(x, y, z) {
        this.holder.position.copyFromFloats(x, y, z);
    }
}
;
class Renderer {
    constructor(container) {
        const antialias = true;
        const options = { preserveDrawingBuffer: true };
        this.engine = new BABYLON.Engine(container.canvas, antialias, options);
        this.scene = new BABYLON.Scene(this.engine);
        const source = new BABYLON.Vector3(0.1, 1.0, 0.3);
        this.light = new BABYLON.HemisphericLight('light', source, this.scene);
        this.scene.clearColor = new BABYLON.Color4(0.8, 0.9, 1.0);
        this.scene.ambientColor = new BABYLON.Color3(1, 1, 1);
        this.light.diffuse = new BABYLON.Color3(1, 1, 1);
        this.light.specular = new BABYLON.Color3(1, 1, 1);
        const scene = this.scene;
        scene.detachControl();
        scene._addComponent(new BABYLON.OctreeSceneComponent(scene));
        this.camera = new Camera(scene);
        this.octree = new BABYLON.Octree(() => { });
        this.octree.blocks = [];
        scene._selectionOctree = this.octree;
        this.blocks = new Map();
    }
    addMesh(mesh, dynamic) {
        if (dynamic) {
            const meshes = this.octree.dynamicContent;
            mesh.onDisposeObservable.add(() => drop(meshes, mesh));
            meshes.push(mesh);
            return;
        }
        const key = this.getMeshKey(mesh);
        const block = this.getMeshBlock(mesh, key);
        mesh.onDisposeObservable.add(() => {
            drop(block.entries, mesh);
            if (block.entries.length)
                return;
            drop(this.octree.blocks, block);
            this.blocks.delete(key);
        });
        block.entries.push(mesh);
        mesh.alwaysSelectAsActiveMesh = true;
        mesh.freezeWorldMatrix();
        mesh.freezeNormals();
    }
    render() {
        this.engine.beginFrame();
        this.scene.render();
        this.engine.endFrame();
    }
    getMeshKey(mesh) {
        assert(!mesh.parent);
        const pos = mesh.position;
        const mod = Constants.CHUNK_SIZE;
        assert(pos.x % mod === 0);
        assert(pos.y % mod === 0);
        assert(pos.z % mod === 0);
        const bits = Constants.CHUNK_KEY_BITS;
        const mask = (1 << bits) - 1;
        return (((pos.x / mod) & mask) << (0 * bits)) |
            (((pos.y / mod) & mask) << (1 * bits)) |
            (((pos.z / mod) & mask) << (2 * bits));
    }
    getMeshBlock(mesh, key) {
        const cached = this.blocks.get(key);
        if (cached)
            return cached;
        const pos = mesh.position;
        const mod = Constants.CHUNK_SIZE;
        const min = new BABYLON.Vector3(pos.x, pos.y, pos.z);
        const max = new BABYLON.Vector3(pos.x + mod, pos.y + mod, pos.z + mod);
        const block = new BABYLON.OctreeBlock(min, max, 0, 0, 0, () => { });
        this.octree.blocks.push(block);
        this.blocks.set(key, block);
        return block;
    }
}
;
class TerrainMesher {
    constructor(scene, registry) {
        this.scene = scene;
        this.flatMaterial = this.makeStandardMaterial('flat-material');
        this.registry = registry;
        this.requests = 0;
        const shim = {
            registry: {
                _solidityLookup: registry._solid,
                _opacityLookup: registry._opaque,
                getBlockFaceMaterial: registry.getBlockFaceMaterial.bind(registry),
                getMaterialData: (x) => registry.getMaterial(x),
                getMaterialTexture: (x) => registry.getMaterial(x).texture,
                _getMaterialVertexColor: (x) => registry.getMaterial(x).color,
            },
            rendering: {
                useAO: true,
                aoVals: [0.93, 0.8, 0.5],
                revAoVal: 1.0,
                flatMaterial: this.flatMaterial,
                addMeshToScene: () => { },
                makeStandardMaterial: this.makeStandardMaterial.bind(this),
                getScene: () => scene,
            },
        };
        this.mesher = new NoaTerrainMesher(shim);
    }
    makeStandardMaterial(name) {
        const result = new BABYLON.StandardMaterial(name, this.scene);
        result.specularColor.copyFromFloats(0, 0, 0);
        result.ambientColor.copyFromFloats(1, 1, 1);
        result.diffuseColor.copyFromFloats(1, 1, 1);
        return result;
    }
    mesh(voxels) {
        const requestID = this.requests++;
        const meshes = [];
        const chunk = {
            voxels,
            requestID,
            pos: null,
            _isFull: false,
            _isEmpty: false,
            _terrainMeshes: meshes,
            _neighbors: { get: (x, y, z) => {
                    const self = x === 0 && y === 0 && z === 0;
                    return self ? { voxels } : null;
                } },
        };
        this.mesher.meshChunk(chunk);
        assert(meshes.length <= 1, () => `Unexpected: ${meshes.length} meshes`);
        return meshes.length === 1 ? meshes[0] : null;
    }
}
;
//////////////////////////////////////////////////////////////////////////////
class Timing {
    constructor(render, update) {
        this.now = performance || Date;
        this.render = render;
        this.update = update;
        const now = this.now.now();
        this.lastRender = now;
        this.lastUpdate = now;
        this.renderBinding = this.renderHandler.bind(this);
        requestAnimationFrame(this.renderBinding);
        this.updateDelay = 1000 / Constants.TICKS_PER_SECOND;
        this.updateLimit = this.updateDelay * Constants.TICKS_PER_FRAME;
        const updateInterval = this.updateDelay / Constants.TICK_RESOLUTION;
        setInterval(this.updateHandler.bind(this), updateInterval);
    }
    renderHandler() {
        requestAnimationFrame(this.renderBinding);
        this.updateHandler();
        const now = this.now.now();
        const dt = now - this.lastRender;
        this.lastRender = now;
        const fraction = (now - this.lastUpdate) / this.updateDelay;
        try {
            this.render(dt, fraction);
        }
        catch (e) {
            this.render = () => { };
            console.error(e);
        }
    }
    updateHandler() {
        let now = this.now.now();
        const delay = this.updateDelay;
        const limit = now + this.updateLimit;
        while (this.lastUpdate + delay < now) {
            try {
                this.update(delay);
            }
            catch (e) {
                this.update = () => { };
                console.error(e);
            }
            this.lastUpdate += delay;
            now = this.now.now();
            if (now > limit) {
                this.lastUpdate = now;
                break;
            }
        }
    }
}
;
;
const kNoEntity = 0;
;
class ComponentStore {
    constructor(component, definition) {
        this.component = component;
        this.definition = definition;
        this.lookup = new Map();
        this.states = [];
    }
    get(entity) {
        const result = this.lookup.get(entity);
        return result ? result : null;
    }
    getX(entity) {
        const result = this.lookup.get(entity);
        if (!result)
            throw new Error(`${entity} missing ${this.component}`);
        return result;
    }
    add(entity) {
        if (this.lookup.has(entity)) {
            throw new Error(`Duplicate for ${entity}: ${this.component}`);
        }
        const index = this.states.length;
        const state = this.definition.init();
        state.id = entity;
        state.index = index;
        this.lookup.set(entity, state);
        this.states.push(state);
        const callback = this.definition.onAdd;
        if (callback)
            callback(state);
    }
    remove(entity) {
        const state = this.lookup.get(entity);
        if (!state)
            return;
        this.lookup.delete(entity);
        const popped = this.states.pop();
        assert(popped.index === this.states.length);
        if (popped.id === entity)
            return;
        const index = state.index;
        assert(index < this.states.length);
        this.states[index] = popped;
        popped.index = index;
        const callback = this.definition.onRemove;
        if (callback)
            callback(state);
    }
    render(dt) {
        const callback = this.definition.onRender;
        if (!callback)
            throw new Error(`render called: ${this.component}`);
        callback(dt, this.states);
    }
    update(dt) {
        const callback = this.definition.onUpdate;
        if (!callback)
            throw new Error(`update called: ${this.component}`);
        callback(dt, this.states);
    }
}
;
class EntityComponentSystem {
    constructor() {
        this.last = 0;
        this.components = new Map();
        this.onRenders = [];
        this.onUpdates = [];
    }
    addEntity(components) {
        this.last = (this.last + 1);
        const result = this.last;
        components.forEach(x => this.addComponent(result, x));
        return result;
    }
    addComponent(entity, component) {
        const store = this.components.get(component);
        if (!store)
            throw new Error(`Unknown component: ${component}`);
        store.add(entity);
    }
    removeEntity(entity) {
        this.components.forEach(x => x.remove(entity));
    }
    registerComponent(component, definition) {
        const exists = this.components.has(component);
        if (exists)
            throw new Error(`Duplicate component: ${component}`);
        const store = new ComponentStore(component, definition);
        this.components.set(component, store);
        if (definition.onRender)
            this.onRenders.push(store);
        if (definition.onUpdate)
            this.onUpdates.push(store);
        return store;
    }
    render(dt) {
        for (const store of this.onRenders)
            store.render(dt);
    }
    update(dt) {
        for (const store of this.onUpdates)
            store.update(dt);
    }
}
;
//////////////////////////////////////////////////////////////////////////////
class Env {
    constructor(id) {
        this.container = new Container(id);
        this.entities = new EntityComponentSystem();
        this.registry = new Registry();
        this.renderer = new Renderer(this.container);
        this.mesher = new TerrainMesher(this.renderer.scene, this.registry);
        this.timing = new Timing(this.render.bind(this), this.update.bind(this));
        const size = Constants.CHUNK_SIZE;
        this.voxels = new Tensor3(size, size, size);
        this._dirty = true;
        this._mesh = null;
    }
    getBlock(x, y, z) {
        return this.voxels.get(x, y, z);
    }
    setBlock(x, y, z, block) {
        this.voxels.set(x, y, z, block);
        this._dirty = true;
    }
    refresh() {
        const saved = this.container.inputs.pointer;
        this.container.inputs.pointer = true;
        this.update(0);
        this.render(0);
        this.container.inputs.pointer = saved;
    }
    render(dt) {
        if (!this.container.inputs.pointer)
            return;
        const deltas = this.container.deltas;
        this.renderer.camera.applyInputs(deltas.x, deltas.y);
        deltas.x = deltas.y = 0;
        this.entities.render(dt);
        this.renderer.render();
    }
    update(dt) {
        if (!this.container.inputs.pointer)
            return;
        if (this._dirty) {
            if (this._mesh)
                this._mesh.dispose();
            this._mesh = this.mesher.mesh(this.voxels);
            if (this._mesh)
                this.renderer.addMesh(this._mesh, false);
            this._dirty = false;
        }
        this.entities.update(dt);
    }
}
;
//////////////////////////////////////////////////////////////////////////////
// The game code:
class TypedEnv extends Env {
    constructor(id) {
        super(id);
        const ents = this.entities;
        this.position = ents.registerComponent('position', Position);
        this.physics = ents.registerComponent('physics', Physics(this));
        this.target = ents.registerComponent('camera-target', CameraTarget(this));
    }
}
;
;
const Position = {
    init: () => ({ id: kNoEntity, index: 0, x: 0, y: 0, z: 0 }),
};
;
const setPhysicsFromPosition = (a, b) => {
    const size = [0.25, 0.25, 0.25];
    b.min = [a.x - size[0], a.y - size[1], a.z - size[2]];
    b.max = [a.x + size[0], a.y + size[1], a.z + size[2]];
};
const setPositionFromPhysics = (a, b) => {
    a.x = (b.min[0] + b.max[0]) / 2;
    a.y = (b.min[1] + b.max[1]) / 2;
    a.z = (b.min[2] + b.max[2]) / 2;
};
const runPhysics = (env, dt, state) => {
    state.vel[1] += -dt * 10;
    const delta = state.vel.map(x => x * dt);
    const impacts = [0, 0, 0];
    //sweep(state.min, state.max, delta, impacts,
    //      (p: Point) => env.getBlock(p[0], p[1], p[2]) === 0);
    for (let i = 0; i < 3; i++) {
        const old_state = state.resting[i];
        const new_state = impacts[i];
        state.resting[i] = new_state;
        if (new_state !== 0)
            state.vel[i] = 0;
        if (new_state && !old_state) {
            console.log(`Impact on axis ${i}: ${impacts[i]}`);
        }
    }
};
const Physics = (env) => ({
    init: () => ({
        id: kNoEntity,
        index: 0,
        min: [0, 0, 0],
        max: [0, 0, 0],
        vel: [0, 0, 0],
        resting: [0, 0, 0],
    }),
    onAdd: (state) => {
        setPhysicsFromPosition(env.position.getX(state.id), state);
    },
    onRemove: (state) => {
        setPositionFromPhysics(env.position.getX(state.id), state);
    },
    onRender: (dt, states) => {
        for (const state of states) {
            setPositionFromPhysics(env.position.getX(state.id), state);
        }
    },
    onUpdate: (dt, states) => {
        for (const state of states) {
            runPhysics(env, dt, state);
        }
    },
});
// CameraTarget signifies that the camera will follow an entity.
const CameraTarget = (env) => ({
    init: () => ({ id: kNoEntity, index: 0 }),
    onRender: (dt, states) => {
        for (const state of states) {
            const position = env.position.getX(state.id);
            env.renderer.camera.setPosition(position.x, position.y, position.z);
        }
    },
    onUpdate: (dt, states) => {
        const inputs = env.container.inputs;
        const ud = (inputs.up ? 1 : 0) - (inputs.down ? 1 : 0);
        const speed = 0.5 * ud;
        const camera = env.renderer.camera;
        const direction = camera.direction;
        for (const state of states) {
            const position = env.position.getX(state.id);
            position.x += speed * direction.x;
            position.y += speed * direction.y;
            position.z += speed * direction.z;
        }
    },
});
// Putting it all together:
const main = () => {
    const env = new TypedEnv('container');
    const player = env.entities.addEntity(['position', 'camera-target']);
    const position = env.position.getX(player);
    position.x = 8;
    position.y = 5;
    position.z = 1.5;
    env.entities.addComponent(player, 'physics');
    const registry = env.registry;
    registry.addMaterialOfColor('grass', [0.2, 0.8, 0.2]);
    registry.addMaterialOfColor('water', [0.4, 0.4, 0.8], 0.6);
    const grass = registry.addBlock(['grass'], true);
    const water = registry.addBlock(['water'], false);
    const size = Constants.CHUNK_SIZE;
    const pl = size / 4;
    const pr = 3 * size / 4;
    for (let x = 0; x < size; x++) {
        for (let z = 0; z < size; z++) {
            const wall = x === 0 || x === size - 1 || z === 0 || z === size - 1;
            const pool = (pl <= x && x < pr && 4 && pl <= z && z < pr);
            const height = Math.min(wall ? 7 : 3, size);
            for (let y = 0; y < height; y++) {
                assert(env.getBlock(x, y, z) === 0);
                const tile = y > 0 && pool ? water : grass;
                env.setBlock(x, y, z, tile);
            }
        }
    }
    env.refresh();
};
window.onload = main;
export {};
//# sourceMappingURL=main.js.map